#+TITLE: Learning Git

* Highlights
* Resources

* [[http://git-scm.com/book][Pro Git Book]]
These are the notes for the freely available book "Pro Git".

** Getting started
- Version control is a system that records changes to a file or set of
  files over time so that you can recall specific versions later
- Centralized version control: If that server goes down for an hour,
  then during that hour nobody can collaborate at all or save
  versioned changes to anything 
- Every time you commit, or save the state of your project in Git, it
  basically takes a picture of what all your files look like
- Git doesn’t need to go out to the server to get the history
- If you get on an airplane or a train and want to do a little work,
  you can commit happily until you get to a network connection to
  upload.
- Git has three main states that your files can reside in: committed,
  modified, and staged.
- *Committed*: data is safely stored in your local database
- *Modified*: changed file, but not committed to database yet.
- *Staged*: marked modified file in its current version to go into next
  commit snapshot.
- Git directory :: where Git stores the metadata and object database 
- working directory :: a single checkout of one version of the project
     placed on disk for you to use or modify
- staging area :: a simple file that stores information about what
                  will go into your next commit
*** installation:
- instructions of book differed in step "grab latest snapshot from http://git-scm.com/download"
- simply used installation for linux recommended on webpage
#+begin_src sh
sudo apt-get install git-core
#+end_src
- consequence: no influence on installation file path
- git not installed as git-repository?
- configure git: for
  - complete system
  - complete user
  - individual repository only
- create .gitconfig file for user configuration
#+begin_src sh
git config --global user.name "John Doe"
git config --global user.email johndoe@example.com
git config --global core.editor emacs
git config --global merge.tool meld
#+end_src
- leading to following file content
#+begin_src file_content
[user]
	name = John Doe
	email = johndoe@example.com
[core]
	editor = emacs
[merge]
	tool = meld
#+end_src

** Git Basics
*** create git repository for existing files
- go to project directory
- starting to track an existing project: create subdirectory named
  .git
- add existing files
- commit project
#+begin_src sh
git init
git add *.org
git commit -m 'first project commit'
#+end_src

*** Cloning an Existing Repository
- git clone: Git receives a copy of nearly all data that the server has
- clone the repository into a directory named something other than
  grit: 
#+begin_src sh
git clone git://github.com/schacon/grit.git mygrit
#+end_src

*** git workflow
- determine files' state:
#+begin_src sh
git status
#+end_src
- git add
  - stages untracked file with snapshot of file at time that adding did occur
  - also stages files that are already tracked
- ignore files: don’t automatically add or show untracked
  (automatically generated files such as log files)
- create .gitignore file
- example: ignore files ending in .o or .a (object and archive files)
  and files that end with a tilde (~)
#+begin_src sh
$ cat .gitignore
*.[oa]
*~
#+end_src
- example: file contents of .gitignore file 
#+begin_src file_content
# a comment - this is ignored
*.a       # no .a files
!lib.a    # but do track lib.a, even though you're ignoring .a files above
/TODO     # only ignore the root TODO file, not subdir/TODO
build/    # ignore all files in the build/ directory
doc/*.txt # ignore doc/notes.txt, but not doc/server/arch.txt
#+end_src
- to see what you’ve changed but not yet staged:
#+begin_src sh
git diff
#+end_src
- to see what you’ve staged that will go into your next commit:
#+begin_src sh
git diff --cached
#+end_src
- git diff by itself doesn’t show all changes made since your last
  commit — only changes that are still unstaged
- Skipping the Staging Area: with -a option to the git commit command
  Git automatically stages every file that is already tracked, letting
  you skip the git add part
- removing files: git rm command also removes the file from your
  working directory
- If you modified the file and added it to the index already, you must
  force the removal with the -f option
- keep the file in your working tree but remove it from your staging
  area: use the --cached option
#+begin_src sh
git rm --cached readme.txt
#+end_src
- If you rename a file in Git, no metadata is stored in Git that tells
  it you renamed the file. To rename a file in Git,  run something
  like
#+begin_src sh
git mv file_from file_to
#+end_src
- Viewing the Commit History: git log
- options -p: show the diff introduced in each commit 
- you can also limit the output to only the last n entries
#+begin_src sh
git log -p -2
#+end_src
- the --stat option prints below each commit entry a list of modified
  files, how many files were changed, and how many lines in those
  files were added and removed
- log option called --graph. This option adds a nice little ASCII
  graph showing your branch and merge history
- show commits made in the last two weeks:
#+begin_src sh
git log --since=2.weeks
#+end_src
- Using a GUI to Visualize History: e.g. gtk 

* github
To connect your local repository to your GitHub account, you will need
to set a remote for your repo and push your commits to it:
#+begin_src sh
git remote add origin https://github.com/username/Hello-World.git
# Creates a remote named "origin" pointing at your GitHub repo

git push origin master
# Sends your commits in the "master" branch to GitHub
#+end_src

* Repos, branches and forks
Different user requirements:
1. completely passively use head of project or last stable version
2. use head of project or last stable version, with additional
   external customizations
3. use externally maintained project with updates, but repeatedly
   incorporate passages of own customizations
4. use externally maintained project with updates, and contribute via branches
5. maintain project alone
6. maintain project together with co-workers

* [[http://www.vogella.com/articles/Git/article.html][Git tutorial]]
To make pushing to remote repositories easier and to avoid unnecessary commits, you can use the following commands.

# Set default so that all changes are always pushed to the repository
git config --global push.default "matching"
# Set default so that you avoid unnecessary commits
git config --global branch.autosetuprebase always 

# Configure Git to use this file
# as global .gitignore

git config --global core.excludesfile ~/.gitignore 

# Initialize the local Git repository
git init
# Add all (files and directories) to the Git repository
git add .

# Commit the changes, -a will commit changes for modified files
# but will not add automatically new files
git commit -a -m "These are new changes" 

The git amend command makes it possible to change the last commit
message.

# Copy one of the older commits and checkout the older revision via 
git checkout commit_name 


* Git repos 
** emacs-repo
structure:
- private files outside of repo
- emacs extensions
  - sometimes as repos itself, with stable branch
- standard configuration files: as org files
- fork: for computer specific settings
- long-term: fork to emacs-god!
** emacs extensions
- auto-complete/auto-complete
- JuliaLang/julia
- emacs-ess/ESS -> development branch 

* Magit
** Installation
- download latest tarball on github
- 
* Forking into John Wiegley
** manually downloaded packages
- use-package
- yasnippet
- haskell-config


#+begin_latex
  \sqrt{2}=x_2 + x⁴
#+end_latex

forking could allow 
- for switching between wl new and old?!
- trying new settings of configuration file
* Captured notes
** installing git 
 #+begin_src sh
$ tar -zxf git-1.7.2.2.tar.gz
$ cd git-1.7.2.2
$ make prefix=/usr/local all
$ sudo make prefix=/usr/local install
#+end_src 

[2012-09-20 Do 10:32]
** 2nd test note 
#+begin_src sh
http://git-scm.com/download
#+end_src 
[2012-09-20 Do 10:34]
** git note from w3m
#+begin_src sh
git add README test.rb LICENSE
git commit -m 'initial commit of my project'
#+end_src 
[[http://git-scm.com/book/en/Git-Branching-What-a-Branch-Is][Git]]
[2012-09-20 Do 10:37]

(set (make-local-variable 'org-refile-targets) (quote (("~/comp_science/notes/git_notes.org" :maxlevel . 1))))
** test work computer committing
this should appear
** install magit


* Magit
** Status
M-x magit-status:
- within a Git repository, it will switch to the status buffer of that repository
- Otherwise, it will prompt for a directory
  - directory that is not a Git repository: ask whether to create one
  - 
- refresh status buffer: g
- 

** Untracked files
- add untracked file with s
- ignore untracked file with i (adds filename to .gitignore)
- ask for file to ignore: C-u i
- add file to .git/info/exclude: I
- delete untracked file: k

** Staging and Committing
- if staging area is ignored, show uncomitted changes as "Changes"
- committing:
  - pop up buffer to write change description: c
  - finish description and commit: C-c C-c

** History
- show history with l
- pop up more information about commit: RET
- apply current commit to current branch: a 
  (useful when browsing history of other branch: applying selected bug fixes)
- show differences from current commit and marked commit: =
- mark commit: ..
- unmark commit: .

** Reflogs
- 
